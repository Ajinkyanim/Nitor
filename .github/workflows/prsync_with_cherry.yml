name: Cherry-pick - Step 1 (manual input only)

on:
  workflow_dispatch:
    inputs:
      commits:
        description: "Comma-separated commit hashes to cherry-pick"
        required: false
        default: ""

env:
  SOURCE_BRANCH: "destination"
  TARGET_BRANCH: "main"
  REUSE_BRANCH: "cp-destination-to-main"
  GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

jobs:
  prepare:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository (full history)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Print environment variables
        run: |
          echo "SOURCE_BRANCH = $SOURCE_BRANCH"
          echo "TARGET_BRANCH = $TARGET_BRANCH"
      
      - name: Print received commits input
        run: |
          echo "Commits input: '${{ github.event.inputs.commits }}'"
      
      - name: Format commits (trim spaces, split by comma)
        id: format_commits
        run: |
          INPUT="${{ github.event.inputs.commits }}"
          if [ -z "$INPUT" ]; then
            echo "No commits provided."
            echo '[]' > commits.json
          else
            echo "$INPUT" | tr ',' '\n' | sed 's/^[ \t]*//;s/[ \t]*$//' | sed '/^$/d' > cleaned.txt
            jq -R . cleaned.txt | jq -s . > commits.json
          fi
      
           echo "Pretty printed commits JSON:"
           cat commits.json | jq .
           
          # Export compact JSON for GitHub Actions output
           COMPACT=$(jq -c . commits.json)
           echo "commits_json=$COMPACT" >> $GITHUB_OUTPUT
      
          # Print compact one-line JSON also (optional)
          echo "Compact JSON: $COMPACT"

      - name: Validate commits
        id: validate_commits
        run: |
          git fetch origin $SOURCE_BRANCH
          git checkout $SOURCE_BRANCH
      
          COMMITS=$(echo '${{ steps.format_commits.outputs.commits_json }}' | jq -r '.[]')
          INVALID=()
          NOT_MERGED=()
      
          for c in $COMMITS; do
            # 1. Check commit object exists in repo
            if git cat-file -e "$c" 2>/dev/null; then
              echo "Commit exists: $c"
            else
              echo "âŒ Commit not found in repo: $c"
              INVALID+=("$c")
              continue
            fi
      
            # 2. Check commit is part of SOURCE_BRANCH history
            if git merge-base --is-ancestor "$c" "origin/$SOURCE_BRANCH"; then
              echo "OK: $c is merged in $SOURCE_BRANCH"
            else
              echo "âŒ Commit $c exists but is NOT merged in $SOURCE_BRANCH"
              NOT_MERGED+=("$c")
            fi
          done
      
          # Fail if any commit is invalid
          if [ ${#INVALID[@]} -ne 0 ]; then
            echo "âŒ Invalid (non-existing) commits: ${INVALID[*]}"
            exit 1
          fi
      
          # Fail if commit exists but NOT merged in source branch
          if [ ${#NOT_MERGED[@]} -ne 0 ]; then
            echo "âŒ Commits exist but are NOT merged into $SOURCE_BRANCH:"
            for c in "${NOT_MERGED[@]}"; do
              echo "  - $c"
            done
            exit 1
          fi

      - name: Check if PR already exists
        id: check_pr
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          BR="$REUSE_BRANCH"
      
          if git ls-remote --exit-code --heads origin "$BR" >/dev/null; then
            echo "Branch exists: $BR"
            echo "Checking if PR already exists"
      
            PR=$(gh pr list \
              --head "$BR" \
              --state open \
              --json number,title,body \
              --jq '.[0]' || true)
      
            if [[ -n "$PR" && "$PR" != "null" ]]; then
              echo "PR already exists:"
              echo "$PR"
              BODY=$(echo "$PR" | jq -r '.body')
      
              echo "=== Please Merge/Close Existing Open PR First Then Run This Pipeline ==="
              exit 1
            else
              echo "No existing PR found for branch: $BR"
            fi
      
          else
            echo "Branch does not exist: $BR"
          fi
     

      - name: Prepare reusable branch
        id: prepare_branch
        run: |
          REUSE_BRANCH="$REUSE_BRANCH"
          echo "reuse_branch=$REUSE_BRANCH" >> $GITHUB_OUTPUT
      
          git fetch origin
      
          if git ls-remote --exit-code --heads origin "$REUSE_BRANCH" >/dev/null; then
            echo "Branch exists. Reusing: $REUSE_BRANCH"
            git checkout "$REUSE_BRANCH"
            git fetch origin $TARGET_BRANCH
            git reset --hard origin/$TARGET_BRANCH
            echo "Force-pushing reset branch to remote..."
            git clean -fdx
            git push --force origin "$REUSE_BRANCH"
          else
            echo "Branch does not exist. Creating: $REUSE_BRANCH"
            git checkout -b "$REUSE_BRANCH" origin/$TARGET_BRANCH   # <-- FIXED
            git clean -fdx
            git push -u origin "$REUSE_BRANCH"
          fi
          

#================================================================================
#================================================================================
      - name: Set up PAT authentication
        run: |
          git config --global user.name "github-actions"
          git config --global user.email "github-actions@github.com"
          git remote set-url origin https://x-access-token:${{ secrets.MY_TOKEN_CLASSIC }}@github.com/${{ github.repository }}.git

      - name: Cherry-pick selected commits
        run: |
          COMMITS=$(echo '${{ steps.format_commits.outputs.commits_json }}' | jq -r '.[]')
          TARGET="$TARGET_BRANCH"

          echo "Starting cherry-pick..."

          # Switch to our reusable branch
          git checkout "${{ steps.prepare_branch.outputs.reuse_branch }}"

          for c in $COMMITS; do
            echo "-----"
            echo "Checking commit: $c"

            # Compute patch-id of the source commit
            PATCH_ID_SRC=$(git show "$c" | git patch-id | awk '{print $1}')

            # Check if same patch already exists in target branch
            if git log origin/$TARGET --patch | git patch-id | grep -q "$PATCH_ID_SRC"; then
              echo "âš ï¸  Commit $c already exists in $TARGET. Skipping."
              continue
            fi

            echo "Cherry-picking $c ..."
            git cherry-pick "$c" || {
              echo "âŒ Conflict while cherry-picking $c"
              exit 1
            }
          done

          echo "ðŸŽ‰ Cherry-pick step completed!"
        env:
          GITHUB_TOKEN: ${{ secrets.MY_TOKEN_CLASSIC }}
          
      - name: Push branch
        run: |
              git push --force origin "${{ steps.prepare_branch.outputs.reuse_branch }}"
    
      - name: Create Pull Request
        if: steps.check_pr.outcome == 'success'
        env:
           GH_TOKEN: ${{ secrets.MY_TOKEN_CLASSIC }}
        run: |
            BR="${{ steps.prepare_branch.outputs.reuse_branch }}"
    
              gh pr create \
                --base "$TARGET_BRANCH" \
                --head "$BR" \
                --title "Cherry-pick: $SOURCE_BRANCH â†’ $TARGET_BRANCH" \
                --body "PR contains cherry-picked commits from $SOURCE_BRANCH."


                
